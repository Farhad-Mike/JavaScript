Install
You may install it globally:
npm install -g win-node-env
Or you may include it in your project's or your library's optional dependencies:
npm install --save-optional win-node-env
It won't install on any other OS than Windows.
html-loader (for images)

/*    Дополнительно    */
Объекты могут быть ключами других объектов.
Symbol.for('name');   // Создать, записать, взять символ из глобального реестра символов
Symbol.kerFor(var);   // По переменной(самому символу) найти название символа
Обычные числа можно писать еще так 2e9 (2000000000). При вызове будет возвращать 2e9
0xabcdef    // Запись 16-ого числа 
0o123       // Запись 8-ого числа
Другим забавным следствием внутреннего представления чисел является наличие двух нулей: 0 и -0. В большинстве случаев это поведение незаметно, так как операторы в JavaScript воспринимают их одинаковыми.
Object.is(var, var); // Сравнивает более точно и даже может сравнить несравневаемые значения нап: (NaN)
Содержимое строки в JavaScript нельзя изменить. Нельзя взять символ посередине и заменить его. Будет ошибка
str.includes('str', pos); возвращает true, если в строке есть подстрока 'str'.
Технически, суррогатные пары возможно обнаружить по их кодам: если код символа находится в диапазоне 0xd800..0xdbff, то это — первая часть суррогатной пары. Следующий символ — вторая часть — имеет код в диапазоне 0xdc00..0xdfff. Эти два диапазона выделены исключительно для суррогатных пар по стандарту.
Методы push и unshift могут добавлять сразу несколько элементов
for of // Посимвольно, поэлементно, [key, value], перебрать итерируемый объект, корректно работает с суррогатными парами
В общем, не следует использовать цикл for..in для массивов.
arr.concat()  // Обычно он просто копирует элементы из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть. Но если объект имеет специальное свойство Symbol.isConcatSpreadable, то он обрабатывается concat как массив: вместо него добавляются его числовые свойства. Для корректной обработки в объекте должны быть числовые свойства и length
ключи в WeakMap должны быть объектами, а не примитивными значениями
Деструктурирующее присваивание, мы можем использовать любой перебираемый объект 


Все матиматический операции кроме бинарного плюса вызывают численное преобразование.
Если для преобразования нету метода obj[Symbol.toPrimitive]() то используется obj.toString()/obj.valueOf() если hint == 'string' или obj.valueOf()/obj.toString() если hint == 'number'/'default'
Если класс вызвать с ключевым словом 'new' то внутри класса 'new.target' примет ссылку на класс объекта, в противном случае 'new.target' будет равно undefined

function User(name){   
    // Защита от дураков. Вот так можно сделать, чтобы функцию можно было вызывать как с, так и без new.
    if (!new.target){ 
        return new User(name);
    };

    this.scream(){} // Так работать не будет в обычной функции, только если использовать конструктор.
    this.name;
}

for (let sym of 'Hello'){alert(sym)} // Посимвольно вызвать
for (let value of arr){alert(value)} // В отличие от обычного цикла тут массив сразу перебирается по значениям, а не по индексу.
let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true, // Если это свойстро задано, то при использовании arr.concat в массив добавятся значения объекта.
  length: 2
};

let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});
arr.findIndex // по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено.
Array.isArray(value) // Он возвращает true, если value массив, и false, если нет.

Можно сделать бесконечный итератор. Например, range будет бесконечным при range.to = Infinity. 
Array.from  принимает объект, проверяет, является ли он итерируемым объектом или псевдомассивом, затем создаёт новый массив и копирует туда все элементы.
Array.from(obj[, mapFn, thisArg]) Необязательный второй аргумент может быть функцией, которая будет применена к каждому элементу перед добавлением в массив, а thisArg позволяет установить this для этой функции.


Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа (реально любого, даже null, NaN, undefined, Infinity).
Методы и свойства:
    new Map() – создаёт коллекцию.
    map.set(key, value) – записывает по ключу key значение value.
    map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
    map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
    map.delete(key) – удаляет элемент по ключу key.
    map.clear() – очищает коллекцию от всех элементов.
    map.size – возвращает текущее количество элементов.
Каждый вызов map.set возвращает объект map, так что мы можем объединить вызовы в цепочку:
map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");
Для перебора коллекции Map есть 3 метода:
    map.keys() – возвращает итерируемый объект по ключам,
    map.values() – возвращает итерируемый объект по значениям,
    map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.
В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление элементов.
map.forEach(function(value, key, map) {});
Object.entries(obj), который получает объект и возвращает массив пар ключ-значение. [ ["name","John"], ["age", 30] ]
Есть метод Object.fromEntries, который делает противоположное: получив массив пар вида [ключ, значение], он создаёт из них объект. Object.fromEntries ожидает перебираемый объект в качестве аргумента, не обязательно массив. 


Math.trunc(3.6) // Просто удаляет дробную часть без округления


Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
Его основные методы это:
    new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
    set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
    set.delete(value) – удаляет значение, возвращает true если value было в множестве на момент вызова, иначе false.
    set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
    set.clear() – удаляет все имеющиеся значения.
    set.size – возвращает количество элементов в множестве.
Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach
Set имеет те же встроенные методы, что и Map:
    set.keys() – возвращает перебираемый объект для значений,
    set.values() – то же самое, что и set.keys(), присутствует для обратной совместимости с Map,
    set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.


Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями.
WeakMap не поддерживает перебор и методы keys(), values(), entries(), так что нет способа взять все ключи или значения из неё.
В WeakMap присутствуют только следующие методы:
    weakMap.get(key)
    weakMap.set(key, value)
    weakMap.delete(key)
    weakMap.has(key)

Коллекция WeakSet ведёт себя похоже:
    Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
    Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
    Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.
  

Array (кроме arr.values()):
  arr.entries();
  arr.keys();

Для простых объектов доступны следующие методы:
    Object.keys(obj) – возвращает массив ключей.
    Object.values(obj) – возвращает массив значений.
    Object.entries(obj) – возвращает массив пар [ключ, значение].
Если требуется учитывать и символьные ключи, то для этого существует отдельный метод Object.getOwnPropertySymbols, возвращающий массив только символьных ключей. Также, существует метод Reflect.ownKeys(obj), который возвращает все ключи.


// второй элемент не нужен title == Consul
let [firstName, , title] = ["Julius", "Caesar", "Consul"] 
На самом деле мы можем использовать любой перебираемый объект, не только массивы
[user.name, user.surname] = "Ilya Kantor".split(' ');
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
// значения по умолчанию
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

// цикл по ключам и значениям
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, then age:30
}

let {var1, var2} = {var1:…, var2:…}
Порядок не имеет значения. Вот так – тоже работает:
// изменён порядок в let {...}
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;
let {width: w = 100, height: h = 200, title} = options; 
// title = свойство с именем title
// rest = объект с остальными свойствами
let {title, ...rest} = options;
Переменные были объявлены в присваивании: let {…} = {…}. Конечно, мы могли бы использовать существующие переменные и не указывать let, но тут есть подвох. Вот так не будет работать:
let title, width, height;
// ошибка будет в этой строке
{title, width, height} = {title: "Menu", width: 200, height: 100};

// мы передаём объект в функцию
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};
// ...и она немедленно извлекает свойства в переменные
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – взято из options,
  // width, height – используются значения по умолчанию
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}
showMenu(options);

function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}


Метод Date.parse(str) считывает дату из строки.
Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ.

JSON является независимой от языка спецификацией для данных, поэтому JSON.stringify пропускает некоторые специфические свойства объектов JavaScript.
А именно:
    Свойства-функции (методы).
    Символьные свойства.
    Свойства, содержащие undefined.
Полный синтаксис JSON.stringify:
let json = JSON.stringify(value[, replacer, space])
value
    Значение для кодирования.
replacer
    Массив свойств для кодирования или функция соответствия function(key, value). Если мы передадим ему массив свойств, будут закодированы только эти свойства, даже вложенные свойста нужно указывать.
space
    Дополнительное пространство (отступы), используемое для форматирования. 

Как и toString для преобразования строк, объект может предоставлять метод toJSON для преобразования в JSON. JSON.stringify автоматически вызывает его, если он есть.
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';
let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

В браузере он называется window, в Node.js — global, в другой среде исполнения может называться иначе. Недавно globalThis был добавлен в язык как стандартизированное имя для глобального объекта, которое должно поддерживаться в любом окружении.
Ещё одно встроенное свойство «length» содержит количество параметров функции в её объявлении. троеточие, обозначающее «остаточные параметры», здесь как бы «не считается»
let func = new Function ([arg1, arg2, ...argN], functionBody); когда функция создаётся с использованием new Function, в её [[Environment]] записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное.
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
Особый вариант использования: setTimeout(func, 0) или просто setTimeout(func).
func.call(context, arg1, arg2, ...)
func.apply(context, args) Он выполняет func, устанавливая this=context и принимая в качестве списка аргументов псевдомассив args.
Метод Object.getOwnPropertyDescriptor позволяет получить полную информацию о свойстве.
Object.defineProperty(obj, prop, descriptor);

let obj = {
  get propName() {
    // геттер, срабатывает при чтении obj.propName
  },
  set propName(value) {
    // сеттер, срабатывает при записи obj.propName = value
  }
};

Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});

Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.
Object.keys возвращает только собственные ключи
obj.hasOwnProperty(key): он возвращает true, если у obj есть собственное, не унаследованное, свойство с именем key.
Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта.
После создания F.prototype может измениться, и новые объекты, созданные с помощью new F(), будут иметь другой объект в качестве [[Prototype]], но уже существующие объекты сохранят старый.
Rabbit.prototype = { constructor: Rabbit };
Современные же методы это:
    Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto, и необязательными дескрипторами свойств descriptors.
    Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.
    Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.
Теперь, если мы хотим использовать объект как ассоциативный массив, мы можем сделать это с помощью небольшого трюка:
let obj = Object.create(null);
let key = prompt("What's the key?", "__proto__");
obj[key] = "some value";
alert(obj[key]); // "some value"

Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства, геттеры/сеттеры и т.д.

class User {
  static staticMethod() {
    alert(this === User);
  }
}
User.staticMethod(); // true

Статические свойства и методы наследуются.
Например, метод Animal.compare в коде ниже наследуется и доступен как Rabbit.compare
// для статики
alert(Rabbit.__proto__ === Animal); // true
// для обычных методов
alert(Rabbit.prototype.__proto__ === Animal.prototype);

в большинстве случаев использование функций get.../set... предпочтительнее: Это выглядит немного длиннее, но функции более гибкие. Они могут принимать несколько аргументов (даже если они нам сейчас не нужны).
class CoffeeMachine {
  _waterAmount = 0;
  setWaterAmount(value) {
    if (value < 0) throw new Error("Отрицательное количество воды");
    this._waterAmount = value;
  }
  getWaterAmount() {
    return this._waterAmount;
  }
}

Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса.
class CoffeeMachine {
  #waterLimit = 200;
  #checkWater(value) {
    if (value < 0) throw new Error("Отрицательный уровень воды");
    if (value > this.#waterLimit) throw new Error("Слишком много воды");
  }
}
coffeeMachine.#checkWater(); // Error
Как мы помним, обычно мы можем получить доступ к полям объекта с помощью this[name]: С приватными свойствами такое невозможно: this['#name'] не работает. Это ограничение синтаксиса сделано для обеспечения приватности.
Обратите внимание на интересный момент: встроенные методы, такие как filter, map и другие возвращают новые объекты унаследованного класса PowerArray. Их внутренняя реализация такова, что для этого они используют свойство объекта constructor.
При помощи специального статического геттера Symbol.species можно вернуть конструктор, который JavaScript будет использовать в filter, map и других методах для создания новых объектов.
  static get [Symbol.species]() {
    return Array;
  }
встроенные классы – исключение. Они не наследуют статические методы друг друга.
obj instanceof Class
Алгоритм работы obj instanceof Class работает примерно так:
    Если имеется статический метод Symbol.hasInstance, тогда вызвать его: Class[Symbol.hasInstance](obj). Он должен вернуть либо true, либо false, и это конец. Это как раз и есть возможность ручной настройки instanceof.
Большая часть классов не имеет метода Symbol.hasInstance. В этом случае используется стандартная логика: проверяется, равен ли Class.prototype одному из прототипов в прототипной цепочке obj.

// скопируем метод toString в переменную для удобства
let objectToString = Object.prototype.toString;
// какой это тип?
let arr = [];
alert( objectToString.call(arr) ); // [object Array]

Symbol.toStringTag
Исключение, которое произойдёт в коде, запланированном «на будущее», например в setTimeout, try..catch не поймает
name
    Имя ошибки. Например, для неопределённой переменной это "ReferenceError".
message
    Текстовое сообщение о деталях ошибки.

В большинстве окружений доступны и другие, нестандартные свойства. Одно из самых широко используемых и поддерживаемых – это:
stack
    Текущий стек вызова: строка, содержащая информацию о последовательности вложенных вызовов, которые привели к ошибке. Используется в целях отладки. 
    
Оператор throw генерирует ошибку.
Если переменную объявить в блоке, например, в try, то она не будет доступна после него.

У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
    state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
    result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).
Свойства state и result – это внутренние свойства объекта Promise и мы не имеем к ним прямого доступа. Для обработки результата следует использовать методы .then/.catch/.finally
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);
Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then(null, errorHandlingFunction). Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает тоже самое
Вызов .finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.
Обработчик, вызываемый из finally, не имеет аргументов. В finally мы не знаем, как был завершён промис. И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.
Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.
Классическая ошибка новичков: технически возможно добавить много обработчиков .then к единственному промису. Но это не цепочка.
Если быть более точными, обработчик может возвращать не именно промис, а любой объект, содержащий метод .then, такие объекты называют «thenable», и этот объект будет обработан как промис.
fetch('/article/promise-chaining/user.json')
  // .then в коде ниже выполняется, когда удалённый сервер отвечает
  .then(function(response) {
    // response.text() возвращает новый промис,
    // который выполняется и возвращает полный ответ сервера,
    // когда он загрузится
    return response.text();
  })
  .then(function(text) {
    // ...и здесь содержимое полученного файла
    alert(text); // {"name": "iliakan", isAdmin: true}
  });

  // то же самое, что и раньше, только теперь response.json() читает данные в формате JSON
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => alert(user.name)); // iliakan, получили имя пользователя

  В браузере мы можем поймать такие ошибки, используя событие unhandledrejection глобальный обработчик если промис не перехватил ошибку window.addEventListener('unhandledrejection', func)

  let promise = Promise.all([...промисы...]); (может принимать любой перебираемый объект, но обычно используется массив) Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов. 
  Обратите внимание, что порядок элементов массива в точности соответствует порядку исходных промисов. 

let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://api.github.com/users/jeresig'
];
// Преобразуем каждый URL в промис, возвращённый fetch
let requests = urls.map(url => fetch(url));
// Promise.all будет ожидать выполнения всех промисов
Promise.all(requests)
  .then(responses => responses.forEach(
    response => alert(`${response.url}: ${response.status}`)
  ));

  Обычно, Promise.all(...) принимает перебираемый объект промисов (чаще всего массив). Но если любой из этих объектов не является промисом, он передаётся в итоговый массив «как есть».

  Метод Promise.allSettled всегда ждёт завершения всех промисов. В массиве результатов будет
    {status:"fulfilled", value:результат} для успешных завершений,
    {status:"rejected", reason:ошибка} для ошибок.

Метод очень похож на Promise.all, но ждёт только первый промис, из которого берёт результат (или ошибку).
let promise = Promise.race(iterable);


Методы Promise.resolve и Promise.reject редко используются в современном коде, так как синтаксис async/await (мы рассмотрим его чуть позже) делает его, в общем-то, не нужным.
Promise.resolve(value) создаёт успешно выполненный промис с результатом value.
Promise.reject(error) создаёт промис, завершённый с ошибкой error

Промисификация:
let loadScriptPromise = function(src) {
  return new Promise((resolve, reject) => {
    loadScript(src, (err, script) => {
      if (err) reject(err)
      else resolve(script);
    });
  })
}
// использование:
// loadScriptPromise('path/script.js').then(...)

function* range(start, end) {
  for (let i = start; i < end; i++) yield i;
}

Для генераторов есть особый синтаксис yield*, который позволяет «вкладывать» генераторы один в другой (осуществлять их композицию).
let generator = gen();
let question = generator.next().value;
generator.throw(new Error("Ответ не найден в моей базе данных")); // (2)
Чтобы сделать объект итерируемым асинхронно:
    Используется Symbol.asyncIterator вместо Symbol.iterator.
    next() должен возвращать промис.
    Чтобы перебрать такой объект, используется цикл for await (let item of iterable).
Оператор расширения ... не работает асинхронно
Из обычного генератора мы можем получить значения при помощи result = generator.next(). Для асинхронного нужно добавить await, вот так

import {sayHi} from './sayHi.js';
Так как модули поддерживают ряд специальных ключевых слов, и у них есть ряд особенностей, то необходимо явно сказать браузеру, что скрипт является модулем, при помощи атрибута <script type="module">. <script type="module" src="user.js"></script>
Каждый модуль имеет свою собственную область видимости.
Если нам нужно сделать глобальную переменную уровня всей страницы, можно явно присвоить её объекту window, тогда получить значение переменной можно обратившись к window.user. Но это должно быть исключением, требующим веской причины.
Оба файла, 1.js и 2.js, импортируют один и тот же объект, изменения, сделанные в 1.js, будут видны в 2.js
Объект import.meta содержит информацию о текущем модуле. (Experimental and not working now
Для модулей атрибут async работает на любых скриптах.)
Внешний скрипт, который загружается с другого домена, требует указания заголовков CORS. Другими словами, если модульный скрипт загружается с другого домена, то удалённый сервер должен установить заголовок Access-Control-Allow-Origin означающий, что загрузка скрипта разрешена.
import * as <obj> from 'path';
import {sayHi as hi, sayBye as bye} from './say.js';
export {sayHi as hi, sayBye as bye};
export default class User {...} / export {sayHi as default}; / import User from ...
Так как в файле может быть максимум один export default, то экспортируемая сущность не обязана иметь имя.
Технически в одном модуле может быть как экспорт по умолчанию, так и именованные экспорты
import {default as User, sayHi} from './user.js';
export {sayHi} from './say.js'; // реэкспортировать sayHi
export {default as User} from './user.js'; // реэкспортировать default
export {default} from './user.js'; // для реэкспорта по умолчанию
export * from './user.js'; // для реэкспорта именованных экспортов
Выражение import(module) загружает модуль и возвращает промис, результатом которого становится объект модуля, содержащий все его экспорты.
Или если внутри асинхронной функции, то можно let module = await import(modulePath).
динамический импорт может выглядеть так:
let {hi, bye} = await import('./say.js');
import(modulePath)
  .then(obj => <объект модуля>)
  .catch(err => <ошибка загрузки, например если нет такого модуля>)


let proxy = new Proxy(target, handler)
  target – это объект, для которого нужно сделать прокси, может быть чем угодно, включая функции.
  handler – конфигурация прокси: объект с «ловушками» («traps»): методами, которые перехватывают разные операции, например, ловушка get – для чтения свойства из target, ловушка set – для записи свойства в target и так далее.
[[Get]] 	              get 	              чтение свойства
[[Set]]                	set 	              запись свойства
[[HasProperty]]       	has 	              оператор in
[[Delete]]            	deleteProperty 	    оператор delete
[[Call]] 	              apply 	            вызов функции
[[Construct]] 	        construct 	        оператор new
[[GetPrototypeOf]] 	    getPrototypeOf 	    Object.getPrototypeOf
[[SetPrototypeOf]] 	    setPrototypeOf 	    Object.setPrototypeOf
[[IsExtensible]] 	      isExtensible 	      Object.isExtensible
[[PreventExtensions]]   preventExtensions 	Object.preventExtensions
[[DefineOwnProperty]] 	defineProperty 	    Object.defineProperty, Object.defineProperties
[[GetOwnProperty]] 	    getOwnPropertyDescriptor 	Object.getOwnPropertyDescriptor, for..in, Object.keys/values/entries
[[OwnPropertyKeys]]     ownKeys 	          Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object.keys/values/entries
Метод [[Set]] должен возвращать true, если значение было успешно записано, иначе false.
Метод [[Delete]] должен возвращать true, если значение было успешно удалено, иначе false.
Метод [[GetPrototypeOf]], применённый к прокси, должен возвращать то же значение, что и метод [[GetPrototypeOf]], применённый к оригинальному объекту. Другими словами, чтение прототипа объекта прокси всегда должно возвращать прототип оригинального объекта.
get(target, property, receiver).
set(target, property, value, receiver):

dictionary = new Proxy(dictionary, {
  get(target, phrase) { // перехватываем чтение свойства в dictionary
    if (phrase in target) { // если перевод для фразы есть в словаре
      return target[phrase]; // возвращаем его
    } else {
      // иначе возвращаем непереведённую фразу
      return phrase;
    }
  }
});

numbers = new Proxy(numbers, { // (*)
  set(target, prop, val) { // для перехвата записи свойства
    if (typeof val == 'number') {
      target[prop] = val;
      return true;
    } else {
      return false;
    }
  }
});
numbers.push(1); // добавилось успешно
numbers.push(2); // добавилось успешно

если мы попробуем возвратить ключ, которого в объекте на самом деле нет, то Object.keys его не выдаст:

Вот так будет работать:
user = new Proxy(user, {
  ownKeys(target) { // вызывается 1 раз для получения списка свойств
    return ['a', 'b', 'c'];
  },
  getOwnPropertyDescriptor(target, prop) { // вызывается для каждого свойства
    return {
      enumerable: true,
      configurable: true
      /* ...другие флаги, возможно, "value: ..." */
    };
  }
});

Для каждого внутреннего метода, перехватываемого Proxy, есть соответствующий метод в Reflect, который имеет такое же имя и те же аргументы, что и у ловушки Proxy.
Reflect.set(user, 'name', 'Вася');

user = new Proxy(user, {
  get(target, prop, receiver) {
    alert(`GET ${prop}`);
    return Reflect.get(target, prop, receiver); // (1)
  },
  set(target, prop, val, receiver) {
    alert(`SET ${prop}=${val}`);
    return Reflect.set(target, prop, val, receiver); // (2)
  }
});

Многие встроенные объекты, например Map, Set, Date, Promise и другие используют так называемые «внутренние слоты» На них proxy не работают 
К счастью, есть способ исправить это:
let map = new Map();
let proxy = new Proxy(map, {
  get(target, prop, receiver) {
    let value = Reflect.get(...arguments);
    return typeof value == 'function' ? value.bind(target) : value;
  }
});
proxy.set('test', 1);
alert(proxy.get('test')); // 1 (работает!)

Нечто похожее происходит и с приватными полями классов.
Например, метод getName() осуществляет доступ к приватному полю #name, после проксирования он перестаёт работать
Решением, как и в предыдущем случае, является привязка контекста к методу:
class User {
  #name = "Гость";
  getName() {
    return this.#name;
  }
}
let user = new User();
user = new Proxy(user, {
  get(target, prop, receiver) {
    let value = Reflect.get(...arguments);
    return typeof value == 'function' ? value.bind(target) : value;
  }
});
alert(user.getName()); // Гость


Однако, такое решение имеет ряд недостатков, о которых уже говорилось: методу передаётся оригинальный объект, который может быть передан куда-то ещё, и это может поломать всю функциональность проксирования.
let object = {
  data: "Важные данные"
};
let {proxy, revoke} = Proxy.revocable(object, {});
// передаём прокси куда-нибудь вместо оригинального объекта...
alert(proxy.data); // Важные данные
// позже в коде
revoke();
// прокси больше не работает (отключён)
alert(proxy.data); // Ошибка


Код в eval выполняется в текущем лексическом окружении, поэтому ему доступны внешние 
В строгом режиме у eval имеется своё лексическое окружение. Поэтому функции и переменные, объявленные внутри eval, нельзя увидеть снаружи
Если код внутри eval не использует внешние переменные, то вызывайте его так – window.eval(...)
В этом случае код выполняется в глобальной области видимости
Если коду внутри eval нужны локальные переменные, поменяйте eval на new Function и передавайте необходимые данные как аргументы:
let f = new Function('a', 'alert(a)');
f(5); // 5

Для каррирования необходима функция с фиксированным количеством аргументов.

 JavaScript побитовые операторы ^, &, | выполняются после сравнений ==.

BigInt можно использовать как обычные числа, к примеру:
alert(1n + 2n); // 3
alert(5n / 2n); // 2
В математических операциях мы не можем смешивать bigint и обычные числа
alert(1n + 2); // Error: Cannot mix BigInt and other types
Мы должны явно их конвертировать: используя либо BigInt(), либо Number()
Конвертирование bigint в число всегда происходит неявно и без генерации ошибок, но если значение bigint слишком велико и не подходит под тип number, то дополнительные биты будут отброшены, так что следует быть осторожными с такими преобразованиями.
К BigInt числам нельзя применить унарный оператор +
Операции сравнения, такие как <, >, работают с bigint и обычными числами как обычно
обычные и bigint числа принадлежат к разным типам, они могут быть равны только при нестрогом сравнении ==
В if или любом другом логическом операторе bigint число ведёт себя как обычное число.
К примеру, в if bigint 0n преобразуется в false, другие значения преобразуются в true
Логические операторы ||, && и другие также работают с bigint числами как с обычными числами:


Intl.Collator
    Умеет правильно сравнивать и сортировать строки.
Intl.DateTimeFormat
    Умеет форматировать дату и время в соответствии с нужным языком.
Intl.NumberFormat
    Умеет форматировать числа в соответствии с нужным языком. 


########################################################################################################################################################################################################################################################################################################################################################################################################################
########################################################################################################################################################################################################################################################################################################################################################################################################################
########################################################################################################################################################################################################################################################################################################################################################################################################################
########################################################################################################################################################################################################################################################################################################################################################################################################################

Браузер: документ, события, интерфейсы:

elem.hasChildNodes() Для проверки наличия дочерних узлов
Для перебора коллекции мы можем использовать for..of
Не используйте цикл for..in для перебора коллекций
document.querySelectorAll(':hover') вернёт коллекцию (в порядке вложенности: от внешнего к внутреннему) из текущих элементов под курсором мыши. возвращает статическую коллекцию. 
elem.querySelector(css) возвращает первый элемент, соответствующий данному CSS
elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору
elem.closest(css) ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.
elem.getElementsByTagName(tag) ищет элементы с данным тегом и возвращает их коллекцию. Передав "*" вместо тега, можно получить всех потомков.
elem.getElementsByClassName(className) возвращает элементы, которые имеют данный CSS-класс.
document.getElementsByName(name) возвращает элементы с заданным атрибутом name. Очень редко используется.
Все методы "getElementsBy*" возвращают живую коллекцию.

console.log(elem) выводит элемент в виде DOM-дерева.
console.dir(elem) выводит элемент в виде DOM-объекта, что удобно для анализа его свойств.

Свойство nodeType предоставляет ещё один, «старомодный» способ узнать «тип» DOM-узла.
Его значением является цифра:
  elem.nodeType == 1 для узлов-элементов,
  elem.nodeType == 3 для текстовых узлов,
  elem.nodeType == 9 для объектов документа,
document.body.tagName
ocument.body.innerHTML = 'Новый BODY!'; // читаем текущее содержимое / заменяем содержимое
Если innerHTML вставляет в документ тег <script> – он становится частью HTML, но не запускается.
elem.outerHTML в отличие от innerHTML, запись в outerHTML не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте.
text.data Из узла читать содержимое
text.nodeValue Из узла читать содержимое
news.textContent Предоставляет доступ к тексту внутри элемента за вычетом всех <тегов>
<div hidden>С атрибутом "hidden"</div>
elem.hidden = true;
value – значение для <input>, <select> и <textarea>
elem.hasAttribute(name) – проверяет наличие атрибута.
elem.getAttribute(name) – получает значение атрибута.
elem.setAttribute(name, value) – устанавливает значение атрибута.
elem.removeAttribute(name) – удаляет атрибут.
elem.attributes получить все атрибуты элемента {name: attrName, value: attrValue}
Когда стандартный атрибут изменяется, соответствующее свойство автоматически обновляется. Это работает и в обратную сторону (за некоторыми исключениями).  эта «особенность» может пригодиться, потому что действия пользователя могут приводить к изменениям value, и если после этого мы захотим восстановить «оригинальное» значение из HTML, оно будет в атрибуте.
DOM-свойства не всегда являются строками. 
alert(input.getAttribute('checked')); // значение атрибута: пустая строка
alert(input.checked); // значение свойства: true
<body data-about="Elephants"> / document.body.dataset.about
data-order-state / dataset.orderState

Методы classList:
    elem.classList.add/remove("class") – добавить/удалить класс.
    elem.classList.toggle("class") – добавить класс, если его нет, иначе удалить.
    elem.classList.contains("class") – проверка наличия класса, возвращает true/false.

Свойство elem.style – это объект, который соответствует тому, что написано в атрибуте "style". Для свойства из нескольких слов используется camelCase.  дефис означает заглавную букву.
div.style.cssText Это свойство редко используется, потому что такое присваивание удаляет все существующие стили.
getComputedStyle(element, [pseudo]) возвращает окончательное значение свойства. При обращении к сокращённому: padding, margin, border – правильный результат не гарантируется.
Посещённые ссылки могут быть окрашены с помощью псевдокласса :visited. getComputedStyle не даёт доступ к этой информации

/*  REACT JS  */

Метод componentDidMount(){} запускается после того, как компонент отрендерился.
componentWillUnmount(){} запускается при удалении компонента
Устаревший и не применяемый методы componentWillReceiveProps(nextProps){}, componentWillMount(){}, componentWillUpdate(){}
shouldComponentUpdate(nextProps, nextState){} Затратный метод. Если вернет true то компонентр обновиться, если false то нет.
getSnapshotBeforeUpdate(){} Очень редко искользуемые жизненные циклы
static getDerivedStateFromProps(props, state){} Очень редко искользуемые жизненные циклы