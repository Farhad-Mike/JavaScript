Install
You may install it globally:
npm install -g win-node-env
Or you may include it in your project's or your library's optional dependencies:
npm install --save-optional win-node-env
It won't install on any other OS than Windows.

Все матиматический операции кроме бинарного плюса вызывают численное преобразование.
Если для преобразования нету метода obj[Symbol.toPrimitive]() то используется obj.toString()/obj.valueOf() если hint == 'string' или obj.valueOf()/obj.toString() если hint == 'number'/'default'
Если класс вызвать с ключевым словом 'new' то внутри класса 'new.target' примет ссылку на класс объекта, в противном случае 'new.target' будет равно undefined

function User(name){   
    // Защита от дураков. Вот так можно сделать, чтобы функцию можно было вызывать как с, так и без new.
    if (!new.target){ 
        return new User(name);
    };

    this.scream(){} // Так работать не будет в обычной функции, только если использовать конструктор.
    this.name;
}

for (let sym of 'Hello'){alert(sym)} // Посимвольно вызвать
for (let value of arr){alert(value)} // В отличие от обычного цикла тут массив сразу перебирается по значениям, а не по индексу.
let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true, // Если это свойстро задано, то при использовании arr.concat в массив добавятся значения объекта.
  length: 2
};

let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});
arr.findIndex // по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено.
Array.isArray(value) // Он возвращает true, если value массив, и false, если нет.

Можно сделать бесконечный итератор. Например, range будет бесконечным при range.to = Infinity. 
Array.from  принимает объект, проверяет, является ли он итерируемым объектом или псевдомассивом, затем создаёт новый массив и копирует туда все элементы.
Array.from(obj[, mapFn, thisArg]) Необязательный второй аргумент может быть функцией, которая будет применена к каждому элементу перед добавлением в массив, а thisArg позволяет установить this для этой функции.


Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа (реально любого, даже null, NaN, undefined, Infinity).
Методы и свойства:
    new Map() – создаёт коллекцию.
    map.set(key, value) – записывает по ключу key значение value.
    map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
    map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
    map.delete(key) – удаляет элемент по ключу key.
    map.clear() – очищает коллекцию от всех элементов.
    map.size – возвращает текущее количество элементов.
Каждый вызов map.set возвращает объект map, так что мы можем объединить вызовы в цепочку:
map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");
Для перебора коллекции Map есть 3 метода:
    map.keys() – возвращает итерируемый объект по ключам,
    map.values() – возвращает итерируемый объект по значениям,
    map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.
В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление элементов.
map.forEach(function(value, key, map) {});
Object.entries(obj), который получает объект и возвращает массив пар ключ-значение. [ ["name","John"], ["age", 30] ]
Есть метод Object.fromEntries, который делает противоположное: получив массив пар вида [ключ, значение], он создаёт из них объект. Object.fromEntries ожидает перебираемый объект в качестве аргумента, не обязательно массив. 


Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
Его основные методы это:
    new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
    set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
    set.delete(value) – удаляет значение, возвращает true если value было в множестве на момент вызова, иначе false.
    set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
    set.clear() – удаляет все имеющиеся значения.
    set.size – возвращает количество элементов в множестве.
Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach
Set имеет те же встроенные методы, что и Map:
    set.keys() – возвращает перебираемый объект для значений,
    set.values() – то же самое, что и set.keys(), присутствует для обратной совместимости с Map,
    set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.


Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями.
WeakMap не поддерживает перебор и методы keys(), values(), entries(), так что нет способа взять все ключи или значения из неё.
В WeakMap присутствуют только следующие методы:
    weakMap.get(key)
    weakMap.set(key, value)
    weakMap.delete(key)
    weakMap.has(key)

Коллекция WeakSet ведёт себя похоже:
    Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
    Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
    Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.
  

Array (кроме arr.values()):
  arr.entries();
  arr.keys();

Для простых объектов доступны следующие методы:
    Object.keys(obj) – возвращает массив ключей.
    Object.values(obj) – возвращает массив значений.
    Object.entries(obj) – возвращает массив пар [ключ, значение].
Если требуется учитывать и символьные ключи, то для этого существует отдельный метод Object.getOwnPropertySymbols, возвращающий массив только символьных ключей. Также, существует метод Reflect.ownKeys(obj), который возвращает все ключи.


// второй элемент не нужен title == Consul
let [firstName, , title] = ["Julius", "Caesar", "Consul"] 
На самом деле мы можем использовать любой перебираемый объект, не только массивы
[user.name, user.surname] = "Ilya Kantor".split(' ');
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
// значения по умолчанию
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

// цикл по ключам и значениям
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, then age:30
}

let {var1, var2} = {var1:…, var2:…}
Порядок не имеет значения. Вот так – тоже работает:
// изменён порядок в let {...}
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;
let {width: w = 100, height: h = 200, title} = options; 
// title = свойство с именем title
// rest = объект с остальными свойствами
let {title, ...rest} = options;
Переменные были объявлены в присваивании: let {…} = {…}. Конечно, мы могли бы использовать существующие переменные и не указывать let, но тут есть подвох. Вот так не будет работать:
let title, width, height;
// ошибка будет в этой строке
{title, width, height} = {title: "Menu", width: 200, height: 100};

// мы передаём объект в функцию
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};
// ...и она немедленно извлекает свойства в переменные
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – взято из options,
  // width, height – используются значения по умолчанию
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}
showMenu(options);

function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}


Метод Date.parse(str) считывает дату из строки.
Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ.

JSON является независимой от языка спецификацией для данных, поэтому JSON.stringify пропускает некоторые специфические свойства объектов JavaScript.
А именно:
    Свойства-функции (методы).
    Символьные свойства.
    Свойства, содержащие undefined.
Полный синтаксис JSON.stringify:
let json = JSON.stringify(value[, replacer, space])
value
    Значение для кодирования.
replacer
    Массив свойств для кодирования или функция соответствия function(key, value). Если мы передадим ему массив свойств, будут закодированы только эти свойства, даже вложенные свойста нужно указывать.
space
    Дополнительное пространство (отступы), используемое для форматирования. 

Как и toString для преобразования строк, объект может предоставлять метод toJSON для преобразования в JSON. JSON.stringify автоматически вызывает его, если он есть.
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';
let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

В браузере он называется window, в Node.js — global, в другой среде исполнения может называться иначе. Недавно globalThis был добавлен в язык как стандартизированное имя для глобального объекта, которое должно поддерживаться в любом окружении.
Ещё одно встроенное свойство «length» содержит количество параметров функции в её объявлении. троеточие, обозначающее «остаточные параметры», здесь как бы «не считается»
let func = new Function ([arg1, arg2, ...argN], functionBody); когда функция создаётся с использованием new Function, в её [[Environment]] записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное.
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
Особый вариант использования: setTimeout(func, 0) или просто setTimeout(func).
func.call(context, arg1, arg2, ...)
func.apply(context, args) Он выполняет func, устанавливая this=context и принимая в качестве списка аргументов псевдомассив args.
Метод Object.getOwnPropertyDescriptor позволяет получить полную информацию о свойстве.
Object.defineProperty(obj, prop, descriptor);

let obj = {
  get propName() {
    // геттер, срабатывает при чтении obj.propName
  },
  set propName(value) {
    // сеттер, срабатывает при записи obj.propName = value
  }
};

Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});

Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.
Object.keys возвращает только собственные ключи
obj.hasOwnProperty(key): он возвращает true, если у obj есть собственное, не унаследованное, свойство с именем key.
Если в F.prototype содержится объект, оператор new устанавливает его в качестве [[Prototype]] для нового объекта.
После создания F.prototype может измениться, и новые объекты, созданные с помощью new F(), будут иметь другой объект в качестве [[Prototype]], но уже существующие объекты сохранят старый.
Rabbit.prototype = { constructor: Rabbit };
Современные же методы это:
    Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как proto, и необязательными дескрипторами свойств descriptors.
    Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.
    Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.
Теперь, если мы хотим использовать объект как ассоциативный массив, мы можем сделать это с помощью небольшого трюка:
let obj = Object.create(null);
let key = prompt("What's the key?", "__proto__");
obj[key] = "some value";
alert(obj[key]); // "some value"

Как и в литеральных объектах, в классах можно объявлять вычисляемые свойства, геттеры/сеттеры и т.д.

class User {
  static staticMethod() {
    alert(this === User);
  }
}
User.staticMethod(); // true

Статические свойства и методы наследуются.
Например, метод Animal.compare в коде ниже наследуется и доступен как Rabbit.compare
// для статики
alert(Rabbit.__proto__ === Animal); // true
// для обычных методов
alert(Rabbit.prototype.__proto__ === Animal.prototype);

в большинстве случаев использование функций get.../set... предпочтительнее: Это выглядит немного длиннее, но функции более гибкие. Они могут принимать несколько аргументов (даже если они нам сейчас не нужны).
class CoffeeMachine {
  _waterAmount = 0;
  setWaterAmount(value) {
    if (value < 0) throw new Error("Отрицательное количество воды");
    this._waterAmount = value;
  }
  getWaterAmount() {
    return this._waterAmount;
  }
}

Приватные свойства и методы должны начинаться с #. Они доступны только внутри класса.
class CoffeeMachine {
  #waterLimit = 200;
  #checkWater(value) {
    if (value < 0) throw new Error("Отрицательный уровень воды");
    if (value > this.#waterLimit) throw new Error("Слишком много воды");
  }
}
coffeeMachine.#checkWater(); // Error
Как мы помним, обычно мы можем получить доступ к полям объекта с помощью this[name]: С приватными свойствами такое невозможно: this['#name'] не работает. Это ограничение синтаксиса сделано для обеспечения приватности.
Обратите внимание на интересный момент: встроенные методы, такие как filter, map и другие возвращают новые объекты унаследованного класса PowerArray. Их внутренняя реализация такова, что для этого они используют свойство объекта constructor.
При помощи специального статического геттера Symbol.species можно вернуть конструктор, который JavaScript будет использовать в filter, map и других методах для создания новых объектов.
  static get [Symbol.species]() {
    return Array;
  }
встроенные классы – исключение. Они не наследуют статические методы друг друга.
obj instanceof Class
Алгоритм работы obj instanceof Class работает примерно так:
    Если имеется статический метод Symbol.hasInstance, тогда вызвать его: Class[Symbol.hasInstance](obj). Он должен вернуть либо true, либо false, и это конец. Это как раз и есть возможность ручной настройки instanceof.
Большая часть классов не имеет метода Symbol.hasInstance. В этом случае используется стандартная логика: проверяется, равен ли Class.prototype одному из прототипов в прототипной цепочке obj.

// скопируем метод toString в переменную для удобства
let objectToString = Object.prototype.toString;
// какой это тип?
let arr = [];
alert( objectToString.call(arr) ); // [object Array]

Symbol.toStringTag
Исключение, которое произойдёт в коде, запланированном «на будущее», например в setTimeout, try..catch не поймает
name
    Имя ошибки. Например, для неопределённой переменной это "ReferenceError".
message
    Текстовое сообщение о деталях ошибки.

В большинстве окружений доступны и другие, нестандартные свойства. Одно из самых широко используемых и поддерживаемых – это:
stack
    Текущий стек вызова: строка, содержащая информацию о последовательности вложенных вызовов, которые привели к ошибке. Используется в целях отладки. 
    
Оператор throw генерирует ошибку.
Если переменную объявить в блоке, например, в try, то она не будет доступна после него.

У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
    state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
    result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).
Свойства state и result – это внутренние свойства объекта Promise и мы не имеем к ним прямого доступа. Для обработки результата следует использовать методы .then/.catch/.finally
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);
Если мы хотели бы только обработать ошибку, то можно использовать null в качестве первого аргумента: .then(null, errorHandlingFunction). Или можно воспользоваться методом .catch(errorHandlingFunction), который сделает тоже самое
Вызов .finally(f) похож на .then(f, f), в том смысле, что f выполнится в любом случае, когда промис завершится: успешно или с ошибкой.
Обработчик, вызываемый из finally, не имеет аргументов. В finally мы не знаем, как был завершён промис. И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.
Обработчик finally «пропускает» результат или ошибку дальше, к последующим обработчикам.
Классическая ошибка новичков: технически возможно добавить много обработчиков .then к единственному промису. Но это не цепочка.
Если быть более точными, обработчик может возвращать не именно промис, а любой объект, содержащий метод .then, такие объекты называют «thenable», и этот объект будет обработан как промис.
fetch('/article/promise-chaining/user.json')
  // .then в коде ниже выполняется, когда удалённый сервер отвечает
  .then(function(response) {
    // response.text() возвращает новый промис,
    // который выполняется и возвращает полный ответ сервера,
    // когда он загрузится
    return response.text();
  })
  .then(function(text) {
    // ...и здесь содержимое полученного файла
    alert(text); // {"name": "iliakan", isAdmin: true}
  });

  // то же самое, что и раньше, только теперь response.json() читает данные в формате JSON
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => alert(user.name)); // iliakan, получили имя пользователя

  В браузере мы можем поймать такие ошибки, используя событие unhandledrejection глобальный обработчик если промис не перехватил ошибку window.addEventListener('unhandledrejection', func)

  let promise = Promise.all([...промисы...]); (может принимать любой перебираемый объект, но обычно используется массив) Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов. 
  Обратите внимание, что порядок элементов массива в точности соответствует порядку исходных промисов. 

let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://api.github.com/users/jeresig'
];
// Преобразуем каждый URL в промис, возвращённый fetch
let requests = urls.map(url => fetch(url));
// Promise.all будет ожидать выполнения всех промисов
Promise.all(requests)
  .then(responses => responses.forEach(
    response => alert(`${response.url}: ${response.status}`)
  ));

  Обычно, Promise.all(...) принимает перебираемый объект промисов (чаще всего массив). Но если любой из этих объектов не является промисом, он передаётся в итоговый массив «как есть».

  Метод Promise.allSettled всегда ждёт завершения всех промисов. В массиве результатов будет
    {status:"fulfilled", value:результат} для успешных завершений,
    {status:"rejected", reason:ошибка} для ошибок.

Метод очень похож на Promise.all, но ждёт только первый промис, из которого берёт результат (или ошибку).
let promise = Promise.race(iterable);


Методы Promise.resolve и Promise.reject редко используются в современном коде, так как синтаксис async/await (мы рассмотрим его чуть позже) делает его, в общем-то, не нужным.
Promise.resolve(value) создаёт успешно выполненный промис с результатом value.
Promise.reject(error) создаёт промис, завершённый с ошибкой error

Промисификация:
let loadScriptPromise = function(src) {
  return new Promise((resolve, reject) => {
    loadScript(src, (err, script) => {
      if (err) reject(err)
      else resolve(script);
    });
  })
}
// использование:
// loadScriptPromise('path/script.js').then(...)

function* range(start, end) {
  for (let i = start; i < end; i++) yield i;
}

Для генераторов есть особый синтаксис yield*, который позволяет «вкладывать» генераторы один в другой (осуществлять их композицию).
let generator = gen();
let question = generator.next().value;
generator.throw(new Error("Ответ не найден в моей базе данных")); // (2)