Все матиматический операции кроме бинарного плюса вызывают численное преобразование.
Если для преобразования нету метода obj[Symbol.toPrimitive]() то используется obj.toString()/obj.valueOf() если hint == 'string' или obj.valueOf()/obj.toString() если hint == 'number'/'default'
Если класс вызвать с ключевым словом 'new' то внутри класса 'new.target' примет ссылку на класс объекта, в противном случае 'new.target' будет равно undefined

function User(name){   
    // Защита от дураков. Вот так можно сделать, чтобы функцию можно было вызывать как с, так и без new.
    if (!new.target){ 
        return new User(name);
    };

    this.scream(){} // Так работать не будет в обычной функции, только если использовать конструктор.
    this.name;
}

for (let sym of 'Hello'){alert(sym)} // Посимвольно вызвать
for (let value of arr){alert(value)} // В отличие от обычного цикла тут массив сразу перебирается по значениям, а не по индексу.
let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true, // Если это свойстро задано, то при использовании arr.concat в массив добавятся значения объекта.
  length: 2
};

let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});
arr.findIndex // по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено.
Array.isArray(value) // Он возвращает true, если value массив, и false, если нет.

Можно сделать бесконечный итератор. Например, range будет бесконечным при range.to = Infinity. 
Array.from в строке (*) принимает объект, проверяет, является ли он итерируемым объектом или псевдомассивом, затем создаёт новый массив и копирует туда все элементы.
Array.from(obj[, mapFn, thisArg]) Необязательный второй аргумент может быть функцией, которая будет применена к каждому элементу перед добавлением в массив, а thisArg позволяет установить this для этой функции.