Install
You may install it globally:
npm install -g win-node-env
Or you may include it in your project's or your library's optional dependencies:
npm install --save-optional win-node-env
It won't install on any other OS than Windows.

Все матиматический операции кроме бинарного плюса вызывают численное преобразование.
Если для преобразования нету метода obj[Symbol.toPrimitive]() то используется obj.toString()/obj.valueOf() если hint == 'string' или obj.valueOf()/obj.toString() если hint == 'number'/'default'
Если класс вызвать с ключевым словом 'new' то внутри класса 'new.target' примет ссылку на класс объекта, в противном случае 'new.target' будет равно undefined

function User(name){   
    // Защита от дураков. Вот так можно сделать, чтобы функцию можно было вызывать как с, так и без new.
    if (!new.target){ 
        return new User(name);
    };

    this.scream(){} // Так работать не будет в обычной функции, только если использовать конструктор.
    this.name;
}

for (let sym of 'Hello'){alert(sym)} // Посимвольно вызвать
for (let value of arr){alert(value)} // В отличие от обычного цикла тут массив сразу перебирается по значениям, а не по индексу.
let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true, // Если это свойстро задано, то при использовании arr.concat в массив добавятся значения объекта.
  length: 2
};

let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});
arr.findIndex // по сути, то же самое, но возвращает индекс, на котором был найден элемент, а не сам элемент, и -1, если ничего не найдено.
Array.isArray(value) // Он возвращает true, если value массив, и false, если нет.

Можно сделать бесконечный итератор. Например, range будет бесконечным при range.to = Infinity. 
Array.from  принимает объект, проверяет, является ли он итерируемым объектом или псевдомассивом, затем создаёт новый массив и копирует туда все элементы.
Array.from(obj[, mapFn, thisArg]) Необязательный второй аргумент может быть функцией, которая будет применена к каждому элементу перед добавлением в массив, а thisArg позволяет установить this для этой функции.


Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа (реально любого, даже null, NaN, undefined, Infinity).
Методы и свойства:
    new Map() – создаёт коллекцию.
    map.set(key, value) – записывает по ключу key значение value.
    map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
    map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
    map.delete(key) – удаляет элемент по ключу key.
    map.clear() – очищает коллекцию от всех элементов.
    map.size – возвращает текущее количество элементов.
Каждый вызов map.set возвращает объект map, так что мы можем объединить вызовы в цепочку:
map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");
Для перебора коллекции Map есть 3 метода:
    map.keys() – возвращает итерируемый объект по ключам,
    map.values() – возвращает итерируемый объект по значениям,
    map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.
В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление элементов.
map.forEach(function(value, key, map) {});
Object.entries(obj), который получает объект и возвращает массив пар ключ-значение. [ ["name","John"], ["age", 30] ]
Есть метод Object.fromEntries, который делает противоположное: получив массив пар вида [ключ, значение], он создаёт из них объект. Object.fromEntries ожидает перебираемый объект в качестве аргумента, не обязательно массив. 


Объект Set – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.
Его основные методы это:
    new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
    set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
    set.delete(value) – удаляет значение, возвращает true если value было в множестве на момент вызова, иначе false.
    set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
    set.clear() – удаляет все имеющиеся значения.
    set.size – возвращает количество элементов в множестве.
Мы можем перебрать содержимое объекта set как с помощью метода for..of, так и используя forEach
Set имеет те же встроенные методы, что и Map:
    set.keys() – возвращает перебираемый объект для значений,
    set.values() – то же самое, что и set.keys(), присутствует для обратной совместимости с Map,
    set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.


Первое его отличие от Map в том, что ключи в WeakMap должны быть объектами, а не примитивными значениями.
WeakMap не поддерживает перебор и методы keys(), values(), entries(), так что нет способа взять все ключи или значения из неё.
В WeakMap присутствуют только следующие методы:
    weakMap.get(key)
    weakMap.set(key, value)
    weakMap.delete(key)
    weakMap.has(key)

Коллекция WeakSet ведёт себя похоже:
    Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
    Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
    Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.
  

Array (кроме arr.values()):
  arr.entries();
  arr.keys();

Для простых объектов доступны следующие методы:
    Object.keys(obj) – возвращает массив ключей.
    Object.values(obj) – возвращает массив значений.
    Object.entries(obj) – возвращает массив пар [ключ, значение].
Если требуется учитывать и символьные ключи, то для этого существует отдельный метод Object.getOwnPropertySymbols, возвращающий массив только символьных ключей. Также, существует метод Reflect.ownKeys(obj), который возвращает все ключи.


// второй элемент не нужен title == Consul
let [firstName, , title] = ["Julius", "Caesar", "Consul"] 
На самом деле мы можем использовать любой перебираемый объект, не только массивы
[user.name, user.surname] = "Ilya Kantor".split(' ');
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
// значения по умолчанию
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

// цикл по ключам и значениям
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, then age:30
}

let {var1, var2} = {var1:…, var2:…}
Порядок не имеет значения. Вот так – тоже работает:
// изменён порядок в let {...}
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;
let {width: w = 100, height: h = 200, title} = options; 
// title = свойство с именем title
// rest = объект с остальными свойствами
let {title, ...rest} = options;
Переменные были объявлены в присваивании: let {…} = {…}. Конечно, мы могли бы использовать существующие переменные и не указывать let, но тут есть подвох. Вот так не будет работать:
let title, width, height;
// ошибка будет в этой строке
{title, width, height} = {title: "Menu", width: 200, height: 100};

// мы передаём объект в функцию
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};
// ...и она немедленно извлекает свойства в переменные
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – взято из options,
  // width, height – используются значения по умолчанию
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}
showMenu(options);

function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}


Метод Date.parse(str) считывает дату из строки.
Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ.

JSON является независимой от языка спецификацией для данных, поэтому JSON.stringify пропускает некоторые специфические свойства объектов JavaScript.
А именно:
    Свойства-функции (методы).
    Символьные свойства.
    Свойства, содержащие undefined.
Полный синтаксис JSON.stringify:
let json = JSON.stringify(value[, replacer, space])
value
    Значение для кодирования.
replacer
    Массив свойств для кодирования или функция соответствия function(key, value). Если мы передадим ему массив свойств, будут закодированы только эти свойства. даже вложенные свойста нужно указывать.
space
    Дополнительное пространство (отступы), используемое для форматирования. 

Как и toString для преобразования строк, объект может предоставлять метод toJSON для преобразования в JSON. JSON.stringify автоматически вызывает его, если он есть.
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';
let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});
Array.from в строке (*) принимает объект, проверяет, является ли он итерируемым объектом или псевдомассивом, затем создаёт новый массив и копирует туда все элементы.
Array.from(obj[, mapFn, thisArg]) Необязательный второй аргумент может быть функцией, которая будет применена к каждому элементу перед добавлением в массив, а thisArg позволяет установить this для этой функции.

В браузере он называется window, в Node.js — global, в другой среде исполнения может называться иначе. Недавно globalThis был добавлен в язык как стандартизированное имя для глобального объекта, которое должно поддерживаться в любом окружении.
Ещё одно встроенное свойство «length» содержит количество параметров функции в её объявлении. троеточие, обозначающее «остаточные параметры», здесь как бы «не считается»
let func = new Function ([arg1, arg2, ...argN], functionBody); когда функция создаётся с использованием new Function, в её [[Environment]] записывается ссылка не на внешнее лексическое окружение, в котором она была создана, а на глобальное.
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
Особый вариант использования: setTimeout(func, 0) или просто setTimeout(func).
func.call(context, arg1, arg2, ...)
func.apply(context, args) Он выполняет func, устанавливая this=context и принимая в качестве списка аргументов псевдомассив args.
